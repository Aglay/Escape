/**
 * $Id$
 * Copyright (C) 2008 - 2009 Nils Asmussen
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */

#ifndef STD_LIST_
#define STD_LIST_

#include <stddef.h>
#include <iterator>

namespace std {
	template<class T>
	class listnode;
	template<class T>
	class listiterator;
	template<class T>
	class const_listiterator;

	template<class T>
	class list {
	public:
		typedef T value_type;
		typedef value_type& reference;
		typedef const value_type& const_reference;
		typedef value_type* pointer;
		typedef const value_type* const_pointer;
		typedef listiterator<T> iterator;
		typedef const_listiterator<T> const_iterator;
		typedef size_t size_type;
		typedef ptrdiff_t difference_type;
		typedef std::reverse_iterator<iterator> reverse_iterator;
		typedef std::reverse_iterator<const_iterator> const_reverse_iterator;

		explicit list();
		explicit list(size_type n,const T& value = T());
		template<class InputIterator>
		list(InputIterator first,InputIterator last);
		list(const list<T>& x);
		~list();

		list<T>& operator =(const list<T>& x);
		template<class InputIterator>
		void assign(InputIterator first,InputIterator last);
		void assign(size_type n,const T& t);

		iterator begin();
		const_iterator begin() const;
		iterator end();
		const_iterator end() const;
		reverse_iterator rbegin();
		const_reverse_iterator rbegin() const;
		reverse_iterator rend();
		const_reverse_iterator rend() const;

		bool empty() const;
		size_type size() const;
		size_type max_size() const;
		void resize(size_type sz,T c = T());

		reference front();
		const_reference front() const;
		reference back();
		const_reference back() const;

		void push_front(const T& x);
		void pop_front();
		void push_back(const T& x);
		void pop_back();

		iterator insert(iterator position,const T& x);
		void insert(iterator position,size_type n,const T& x);
		template<class InputIterator>
		void insert(iterator position,InputIterator first,InputIterator last);

		iterator erase(iterator position);
		iterator erase(iterator position,iterator last);
		void clear();

		void splice(iterator position,list<T>& x);
		void splice(iterator position,list<T>& x,iterator i);
		void splice(iterator position,list<T>& x,iterator first,iterator last);

		void remove(const T& value);
		template<class Predicate>
		void remove_if(Predicate pred);

		void unique();
		template<class BinaryPredicate>
		void unique(BinaryPredicate binary_pred);

		void merge(list<T>& x);
		template<class Compare>
		void merge(list<T>& x,Compare comp);

		void sort();
		template<class Compare>
		void sort(Compare comp);

		void reverse();
		void swap(list<T>&);

	private:
		size_type _count;
		listnode<T> _head;
		listnode<T> _foot;
	};
}

#include "../../lib/cpp/src/list.cc"

#endif /* STD_LIST_ */
