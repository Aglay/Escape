__doc__=="""
xmark.py -- A 1989 DOS 386 asm benchmark revisited
Last modified: Sun May 16 1999
This code is Copyright (C)1999 Jeff Epler
"""

import sys
import time
import string

prologue = """
#define cpuid
/* 
 * xmark.S -- Generated by xmark.py
 */ 

.data
count:		.int  8
Output:		.int 0; .int 1
.text
"""

epilogue="""
.setup:
	xorl  %ecx,%ecx
	xorl  %edi,%edi
	xorl  %esi,%esi
	xorl  %ebx,%ebx
	xorl  %ebp,%ebp
	finit
	fld1; fld1; fld1; fld1
	fld1; fld1; fld1; fld1
	ret

.mmxsetup:
	xorl  %ecx,%ecx
	xorl  %edi,%edi
	xorl  %esi,%esi
	xorl  %ebx,%ebx
	xorl  %ebp,%ebp
	emms
	ret
"""

nreg = [ "" ]
mreg = [ "%ebx" ]

# edi, edx, esi, ebp are "src-result" registers: dirtied in turn
# ebx is "result-only" register: dirtied each time
# eax, esp are "source" registers: should never be dirtied

ireg = [ "%eax, %edi",
	"%esp, %edx",
	"%eax, %esi",
	"%esp, %ebp"]

MMreg= [ "%mm0, %mm1",
	"%mm0, %mm2",
	"%mm0, %mm3",
	"%mm0, %mm4",
	"%mm0, %mm5",
	"%mm0, %mm6"]

dMMreg = [ "%mm7, %mm7" ]

# Absolute memory operands
Alreg = [ "count, %ebx" ]
ASreg = [ "%eax, Output",
	  "%esp, 4+Output" ]
	       
# Relative memory operands
lreg = [ "(%esp), %ebx" ]
Sreg = [ "%eax, 4(%esp)",
	 "%esp, 8(%esp)" ]
	       
sreg = [ "%esi", "%ebp", "%edi", "%edx" ]
f2reg = ["%st, %st(1)",
	"%st, %st(2)"]
freg = ["%st, %st(1)",
	"%st, %st(2)",
	"%st, %st(3)",
	"%st, %st(4)",
	"%st, %st(5)",
	"%st, %st(6)",
	"%st, %st(7)"]

class Jreg:	
	def __init__(self):
		self.i = 0
	def __getitem__(self, i):
		self.i = self.i + 1
		return "L%03d\n.align 32\nL%03d:" % (self.i, self.i)

	def __len__(self): return 999

class UJreg(Jreg):
	def __getitem__(self, i):
		self.i = self.i + 1
		return "UL%03d\nUL%03d:" % (self.i, self.i)

jreg = Jreg()
ujreg = UJreg()

count=16
def do_one(label, op1, op1type, op2, op2type, file=None, mmx=0):
	file = file or sys.stdout
	c1 = 0
	if len(op1type)>1 and op1type is op2type: c2 = 1
	else: c2 = 0
	if mmx:
		file.write(".globl %s\n.align 32\n%s:"
			   "\tpushl %%esi; pushl %%edi;\n"
			   "\tpushl %%ebx; pushl %%ebp\n"
			   "\tcall  .mmxsetup\n" % (label,label,))
	else:
		file.write(".globl %s\n.align 32\n%s:"
			   "\tpushl %%esi; pushl %%edi;\n"
			   "\tpushl %%ebx; pushl %%ebp\n"
			   "\tcall  .setup\n" % (label,label,))
	file.write("cpuid; rdtsc; movl %eax, count; xorl %eax, %eax; xorl %edx, %edx\n");
	for i in range(count):
		file.write("\t%-5s %s\n" % (op1, op1type[c1]))
		file.write("\t%-5s %s\n" % (op2, op2type[c2]))
		if op1type is op2type:
			c1 = (c1+2) % len(op1type)
			c2 = (c2+2) % len(op1type)
		else:
			c1 = (c1+1) % len(op1type)
			c2 = (c2+1) % len(op2type)
	file.write("\tcpuid; rdtsc; subl count, %eax\n")
	if mmx: file.write("\temms\n")
	else: file.write("\tfinit\n")
	file.write("\tpopl %ebp; popl %ebx; popl %edi; popl %esi; ret\n")

cfile = open("x86mark.c", "w")

first = 1
def doit(file, *tests):
	global first
	file.write(prologue)
	if not first:
		cfile.write("NL()\n");
	else:
		first=0
	print tests[0]
	for label, name, op1, op1type, op2, op2type, mmx in tests:
		cfile.write("DOTEST(%s, %s, level%d)\n" % (label, name, mmx));
		do_one(label, op1, op1type, op2, op2type, file=file, mmx=mmx)
	file.write(epilogue)

modes = {
	"add": ("addl", ireg),
	"madd": ("addl", lreg),
	"mul": ("mull", mreg),
	"shl": ("shll", sreg),
	"fmul": ("fmul", freg),
	"fadd": ("fadd", freg),
	"f2add": ("fadd", f2reg),
	"fdiv": ("fdiv", freg),
	"jmp": ("jmp", jreg),
	"ujmp": ("jmp", ujreg),
	"load": ("movl", lreg),
	"store": ("movl", ASreg),
	"nop": ("nop", nreg),
	"fsin": ("fsin", nreg),
	"fsqrt": ("fsqrt", nreg),
	"amadd": ("addl", Alreg),
	"ohead": ("", [""]),
	"dadd": ("addl", ["%eax, %eax"]),
	"dmul": ("mull", ["%edx"]),
	"edx": ("addl", ["%edx, %edx"]),
	"eax": ("addl", ["%eax, %eax"]),
	"dshl": ("shll", ["%eax"]),
	"dfadd": ("fadd", ["%st(1), %st"]),
	"dfadd1": ("fadd", ["%st, %st(1)"]),
	"f7add": ("fadd", ["%st(7), %st"]),
	"ifadd": ("fadd", ["%st, %st(1)"]),
	"dfmul": ("fmul", ["%st(1), %st"]),
	"ifmul": ("fmul", ["%st, %st(1)"]),
	"dfdiv": ("fdiv", ["%st(0)"]),
	"pfmul": ("pfmul", MMreg),
	"pfadd": ("pfadd", MMreg),
	"pxor": ("pxor", MMreg),
	"paddw": ("paddw", MMreg),
	"pmullw": ("pmullw", MMreg),
	"dpxor": ("pxor", dMMreg),
	"dpaddw": ("paddw", dMMreg),
	"dpmullw": ("pmullw", dMMreg),
	"dpfmul": ("pfmul", dMMreg),
	"dpfadd": ("pfadd", dMMreg),
}

def mkmode(mode1, mode2=None, mmx=0):
	if mode2 is None: mode2=mode1
	if(mode1 == mode2):
		return ((mode1+mode2, string.upper(mode1)) + 
			modes[mode1]+modes[mode2] + (mmx,))
	else:
		return ((mode1+mode2, string.upper(mode1+"-"+mode2)[:13]) + 
			modes[mode1]+modes[mode2] + (mmx,))

cfile.write(r"""
#define DATE "%s"
#define INSTRUCTIONS "%d"
""" % (time.ctime(time.time()), count*2))

cfile.write(r"""
#define DOTEST(x,y,t) \
if (t) {							\
	extern int x(void);					\
	x(); a=x(); printf("%13s=%4d", #y, a-ohead);		\
	pos=pos+1;						\
	if(pos==4) {						\
		printf("\n");					\
		pos=0;						\
	} else {						\
		printf(" ");					\
	}							\
}

#define NL()							\
	if(pos!=0) {						\
		printf("\n");					\
		pos=0;						\
	}							\
	printf("\n");

int main(void) {
	int ohead, a, pos=0;
	int level0=1,
		level1=!system("grep -q mmx /proc/cpuinfo > /dev/null 2>&1"),
		level2=!system("grep -q 3dnow /proc/cpuinfo > /dev/null 2>&1");
	extern int oheadohead();
	oheadohead();
	ohead = oheadohead();
	printf("x86mark generated "DATE" --"
		" cycle counts per "INSTRUCTIONS" instructions\n");
		
""")

doit(open("x86.S", "w"),
	mkmode("add", "add"),
	mkmode("mul", "mul"),
	mkmode("shl", "shl"),
	mkmode("add", "mul"),
	mkmode("add", "shl"),
	mkmode("jmp", "jmp"),
	mkmode("ujmp", "ujmp"),
	mkmode("add", "jmp"))

doit(open("x87.S", "w"),
	mkmode("fadd", "fadd"),
	mkmode("fmul", "fmul"),
	mkmode("fmul", "fadd"),
	mkmode("fdiv", "fdiv"),
	mkmode("fmul", "fdiv"),
	mkmode("fadd", "fdiv"),
	mkmode("fsqrt", "fsqrt"),
	mkmode("fsin", "fsin"))

doit(open("x86mem.S", "w"),
	mkmode("madd", "madd"),
	mkmode("madd", "add"),
	mkmode("amadd", "add"),
	mkmode("add", "store"),
	mkmode("add", "load"),
	mkmode("load", "store"),
	mkmode("load", "load"),
	mkmode("store", "store"))

doit(open("x86mix.S", "w"),
	mkmode("add", "fmul"),
	mkmode("mul", "fmul"),
	mkmode("shl", "fmul"),
	mkmode("add", "fadd"),
	mkmode("mul", "fadd"),
	mkmode("shl", "fadd"),
	mkmode("add", "fdiv"),
	mkmode("ohead", "ohead"))    

doit(open("x86odd.S", "w"),
	mkmode("ifadd", "ifadd"),
	mkmode("f7add", "f7add"),
	mkmode("f2add", "f2add"),
	mkmode("ifmul", "ifmul"))

doit(open("x86dep.S", "w"),
	mkmode("dfadd", "dfadd"),
	mkmode("dfadd1", "dfadd1"),
	mkmode("dfmul", "dfmul"),
	mkmode("dfdiv", "dfdiv"),
#	mkmode("dload", "dload"),
	mkmode("dadd", "dadd"),
	mkmode("dmul", "eax"),
	mkmode("dmul", "edx"),
#	mkmode("dshl", "dshl")
)

doit(open("k6-3d.S", "w"),
	mkmode("pfmul", "pfmul", 2),
	mkmode("pfadd", "pfadd", 2),
	mkmode("pfadd", "pfmul", 2),
	mkmode("dpfmul", "dpfmul", 2),
	mkmode("dpfadd", "dpfadd", 2),
	mkmode("dpfadd", "dpfmul", 2)
)

doit(open("mmx.S", "w"),
	mkmode("pxor", "pxor", 1),
	mkmode("paddw", "paddw", 1),
	mkmode("pmullw", "pmullw", 1),
	mkmode("dpxor", "dpxor", 1),
	mkmode("dpaddw", "dpaddw", 1),
	mkmode("dpmullw", "dpmullw", 1),
	mkmode("pxor", "paddw", 1),
	mkmode("pxor", "pmullw", 1),
	mkmode("paddw", "pmullw", 1)
)

cfile.write('if(pos) printf("\\n");return 0;\n}')
