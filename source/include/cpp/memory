/**
 * $Id$
 * Copyright (C) 2008 - 2009 Nils Asmussen
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */

#pragma once

#include <bits/c++config.h>
#include <stddef.h>
#include <functional>
#include <algorithm>
#include <utility>
#include <ostream>
#include <assert.h>

namespace std {
	template<class T>
	class unique_ptr {
		template<class T2>
		friend class unique_ptr;

	public:
		typedef T* pointer;
		typedef T element_type;

		// 20.7.1.2.1, constructors
		constexpr unique_ptr() noexcept
			: _ptr() {
		}
		explicit unique_ptr(pointer p) noexcept
			: _ptr(p) {
		}
		unique_ptr(unique_ptr&& u) noexcept
			: _ptr(u.release()) {
		}
		template<class U>
		unique_ptr(unique_ptr<U>&& u) noexcept
			: _ptr(u.release()) {
		}

		// 20.7.1.2.2, destructor
		~unique_ptr() {
			delete _ptr;
		}

		// 20.7.1.2.3, assignment
		unique_ptr& operator=(unique_ptr&& u) noexcept {
			if(_ptr != u._ptr)
				reset(u.release());
			return *this;
		}
		template<class U>
		unique_ptr& operator=(unique_ptr<U>&& u) noexcept {
			if(_ptr != u._ptr)
				reset(u.release());
			return *this;
		}

		// 20.7.1.2.4, observers
		T& operator*() const {
			assert(get() != nullptr);
			return *get();
		}
		pointer operator->() const noexcept {
			assert(get() != nullptr);
			return get();
		}
		pointer get() const noexcept {
			return _ptr;
		}
		CASTOP_EXPLICIT operator bool() const noexcept {
			return get() != nullptr;
		}

		// 20.7.1.2.5 modifiers
		pointer release() noexcept {
			pointer p = _ptr;
			_ptr = nullptr;
			return p;
		}
		void reset(pointer p = pointer()) noexcept {
			delete _ptr;
			_ptr = p;
		}
		void swap(unique_ptr& u) noexcept {
			std::swap(_ptr,u._ptr);
		}

		// disable copy from lvalue
		unique_ptr(const unique_ptr&) = delete;
		unique_ptr& operator=(const unique_ptr&) = delete;

	private:
		T *_ptr;
	};

	template<class T>
	class unique_ptr<T[]> {
		template<class T2>
		friend class unique_ptr;

	public:
		typedef T* pointer;
		typedef T element_type;

		// 20.7.1.3.1, constructors
		constexpr unique_ptr() noexcept
			: _ptr() {
		}
		explicit unique_ptr(pointer p) noexcept
			: _ptr(p) {
		}
		unique_ptr(unique_ptr&& u) noexcept
			: _ptr(u.release()) {
		}

		// destructor
		~unique_ptr() {
			delete[] _ptr;
		}

		// assignment
		unique_ptr& operator=(unique_ptr&& u) noexcept {
			if(_ptr != u._ptr)
				reset(u.release());
			return *this;
		}

		// 20.7.1.3.2, observers
		T& operator[](size_t i) const {
			assert(get() != nullptr);
			return _ptr[i];
		}
		pointer get() const noexcept {
			return _ptr;
		}
		CASTOP_EXPLICIT operator bool() const noexcept {
			return get() != nullptr;
		}

		// 20.7.1.3.3 modifiers
		pointer release() noexcept {
			pointer p = _ptr;
			_ptr = nullptr;
			return p;
		}
		void reset(pointer p = pointer()) noexcept {
			delete[] _ptr;
			_ptr = p;
		}
		template<class U>
		void reset(U) = delete;
		void swap(unique_ptr& u) noexcept {
			std::swap(_ptr,u._ptr);
		}

		// disable copy from lvalue
		unique_ptr(const unique_ptr&) = delete;
		unique_ptr& operator=(const unique_ptr&) = delete;

	private:
		T *_ptr;
	};

	template<class T>
	void swap(unique_ptr<T>& x, unique_ptr<T>& y) noexcept {
		x.swap(y);
	}

	template<class T1,class T2>
	inline bool operator==(const unique_ptr<T1>& x, const unique_ptr<T2>& y) {
		return x.get() == y.get();
	}
	template<class T1, class T2>
	inline bool operator!=(const unique_ptr<T1>& x, const unique_ptr<T2>& y) {
		return !(x == y);
	}
	template<class T1, class T2>
	inline bool operator<(const unique_ptr<T1>& x, const unique_ptr<T2>& y) {
		return x.get() < y.get();
	}
	template<class T1, class T2>
	inline bool operator<=(const unique_ptr<T1>& x, const unique_ptr<T2>& y) {
		return !(x > y);
	}
	template<class T1, class T2>
	inline bool operator>(const unique_ptr<T1>& x, const unique_ptr<T2>& y) {
		return x.get() > y.get();
	}
	template<class T1, class T2>
	inline bool operator>=(const unique_ptr<T1>& x, const unique_ptr<T2>& y) {
		return !(x < y);
	}

	class bad_weak_ptr : public std::exception {
	public:
		bad_weak_ptr() noexcept
			: exception() {
		}
	    virtual const char* what() const throw() {
	    	return "bad_weak_ptr";
	    }
	};

	template<class T>
	class refobject {
	public:
		explicit refobject(T *ptr_,long shared,long weak) noexcept
			: shared_refs(shared), weak_refs(weak), ptr(ptr_) {
		}

		refobject(const refobject&) = delete;
		refobject& operator=(const refobject&) = delete;

		long shared_refs;
		long weak_refs;
		T *ptr;
	};

	template<class T>
	class weak_ptr;

	template<class From,class To>
	struct IsConvertible {
		void check() {
			To y A_UNUSED = _x;
		}
		From _x;
	};
	template<class From,class To>
	struct IsConstConvertible {
		void check() {
			To y A_UNUSED = const_cast<To>(_x);
		}
		From _x;
	};
	template<class From,class To>
	struct IsStaticConvertible {
		void check() {
			To y A_UNUSED = static_cast<To>(_x);
		}
		From _x;
	};

	template<class Concept>
	inline void function_requires() {
		void (Concept::*_x)() A_UNUSED = &Concept::check;
	}

	template<class T>
	class shared_ptr {
		template<class Y>
		friend class shared_ptr;
		template<class Y>
		friend class weak_ptr;

	public:
		typedef T element_type;

		// 20.7.2.2.1, constructors:
		constexpr shared_ptr() noexcept
			: _obj() {
		}
		template<class Y>
		explicit shared_ptr(Y* p)
			: _obj(p ? new refobject<T>(p,1,0) : nullptr) {
		}
		shared_ptr(const shared_ptr& r) noexcept
			: _obj(r._obj) {
			attach();
		}
		template<class Y>
		shared_ptr(const shared_ptr<Y>& r) noexcept
			: _obj((refobject<T>*)r._obj) {
			function_requires<IsConvertible<Y*,T*>>();
			attach();
		}
		shared_ptr(shared_ptr&& r) noexcept
			: _obj(r._obj) {
			r._obj = nullptr;
		}
		template<class Y>
		shared_ptr(shared_ptr<Y>&& r) noexcept
			: _obj((refobject<T>*)r._obj) {
			function_requires<IsConvertible<Y*,T*>>();
			r._obj = nullptr;
		}
		template<class Y>
		explicit shared_ptr(const weak_ptr<Y>& r)
			: _obj((refobject<T>*)r._obj) {
			function_requires<IsConvertible<Y*,T*>>();
			attach();
		}
		template<class Y>
		shared_ptr(unique_ptr<Y>&& r)
			: _obj(r.get() ? new refobject<T>(r.release(),1,0) : nullptr) {
		}

		// 20.7.2.2.2, destructor:
		~shared_ptr() {
			detach();
		}

		// 20.7.2.2.3, assignment:
		shared_ptr& operator=(const shared_ptr& r) noexcept {
			if(_obj != r._obj) {
				detach();
				attachTo(r._obj);
			}
			return *this;
		}
		template<class Y>
		shared_ptr& operator=(const shared_ptr<Y>& r) noexcept {
			function_requires<IsConvertible<Y*,T*>>();
			if(_obj != (refobject<T>*)r._obj) {
				detach();
				attachTo((refobject<T>*)r._obj);
			}
			return *this;
		}
		shared_ptr& operator=(shared_ptr&& r) noexcept {
			if(_obj != r._obj) {
				detach();
				_obj = r._obj;
				r._obj = nullptr;
			}
			return *this;
		}
		template<class Y>
		shared_ptr& operator=(shared_ptr<Y>&& r) noexcept {
			function_requires<IsConvertible<Y*,T*>>();
			if(_obj != (refobject<T>*)r._obj) {
				detach();
				_obj = (refobject<T>*)r._obj;
				r._obj = nullptr;
			}
			return *this;
		}
		template<class Y>
		shared_ptr& operator=(unique_ptr<Y>&& r) {
			detach();
			_obj = r.get() ? new refobject<T>(r.release(),1,0) : nullptr;
			return *this;
		}

		// 20.7.2.2.4, modifiers:
		void swap(shared_ptr& r) noexcept {
			std::swap(_obj,r._obj);
		}
		void reset() noexcept {
			shared_ptr().swap(*this);
		}
		template<class Y>
		void reset(Y* p) {
			shared_ptr(p).swap(*this);
		}

		// 20.7.2.2.5, observers:
		T* get() const noexcept {
			return _obj ? _obj->ptr : nullptr;
		}
		T& operator*() const noexcept {
			assert(get() != nullptr);
			return *get();
		}
		T* operator->() const noexcept {
			assert(get() != nullptr);
			return get();
		}

		long use_count() const noexcept {
			return _obj ? _obj->shared_refs : 0;
		}
		bool unique() const noexcept {
			return use_count() == 1;
		}
		CASTOP_EXPLICIT operator bool() const noexcept {
			return get() != nullptr;
		}

		template<class T2,class U>
		friend shared_ptr<T2> static_pointer_cast(const shared_ptr<U>& r) noexcept;
		template<class T2,class U>
		friend shared_ptr<T2> dynamic_pointer_cast(const shared_ptr<U>& r) noexcept;
		template<class T2,class U>
		friend shared_ptr<T2> const_pointer_cast(const shared_ptr<U>& r) noexcept;

	private:
		void attach() {
			if(_obj)
				_obj->shared_refs++;
		}
		void attachTo(refobject<T> *obj) {
			_obj = obj;
			attach();
		}
		void detach() {
			if(_obj && --_obj->shared_refs == 0) {
				delete _obj->ptr;
				_obj->ptr = nullptr;
				if(_obj->weak_refs == 0)
					delete _obj;
			}
		}

		refobject<T> *_obj;
	};

	// 20.7.2.2.6, shared_ptr creation
	template<class T,class ... Args>
	inline shared_ptr<T> make_shared(Args&&... args) {
		return shared_ptr<T>(new T(std::forward<Args...>(args...)));
	}

	// 20.7.2.2.7, shared_ptr comparisons:
	template<class T,class U>
	inline bool operator==(const shared_ptr<T>& a,const shared_ptr<U>& b) noexcept {
		return a.get() == b.get();
	}
	template<class T,class U>
	inline bool operator!=(const shared_ptr<T>& a,const shared_ptr<U>& b) noexcept {
		return !(a == b);
	}
	template<class T,class U>
	inline bool operator<(const shared_ptr<T>& a,const shared_ptr<U>& b) noexcept {
		return a.get() < b.get();
	}
	template<class T,class U>
	inline bool operator>(const shared_ptr<T>& a,const shared_ptr<U>& b) noexcept {
		return a.get() > b.get();
	}
	template<class T,class U>
	inline bool operator<=(const shared_ptr<T>& a,const shared_ptr<U>& b) noexcept {
		return !(a > b);
	}
	template<class T,class U>
	inline bool operator>=(const shared_ptr<T>& a,const shared_ptr<U>& b) noexcept {
		return !(a < b);
	}

	// 20.7.2.2.8, shared_ptr specialized algorithms:
	template<class T>
	inline void swap(shared_ptr<T>& a,shared_ptr<T>& b) noexcept {
		return a.swap(b);
	}

	// 20.7.2.2.9, shared_ptr casts:
	template<class T,class U>
	inline shared_ptr<T> static_pointer_cast(const shared_ptr<U>& r) noexcept {
		function_requires<IsStaticConvertible<U*,T*>>();
		shared_ptr<T> res;
		res.attachTo((refobject<T>*)r._obj);
		return res;
	}
	template<class T,class U>
	inline shared_ptr<T> dynamic_pointer_cast(const shared_ptr<U>& r) noexcept {
		shared_ptr<T> res;
		T *t;
		if(r && (t = dynamic_cast<T*>(r.get())))
			res.attachTo((refobject<T>*)r._obj);
		return res;
	}
	template<class T,class U>
	inline shared_ptr<T> const_pointer_cast(const shared_ptr<U>& r) noexcept {
		function_requires<IsConstConvertible<U*,T*>>();
		shared_ptr<T> res;
		res.attachTo((refobject<T>*)r._obj);
		return res;
	}

	// 20.7.2.2.11, shared_ptr I/O:
	template<class Y>
	inline ostream& operator<<(ostream& os,const shared_ptr<Y>& p) {
		os << p.get();
		return os;
	}

	template<class T>
	class weak_ptr {
		template<class Y>
		friend class weak_ptr;
		template<class Y>
		friend class shared_ptr;

	public:
		typedef T element_type;

		// 20.7.2.3.1, constructors
		constexpr weak_ptr() noexcept
			: _obj() {
		}
		template<class Y>
		weak_ptr(shared_ptr<Y> const& r) noexcept
			: _obj((refobject<T>*)r._obj) {
			function_requires<IsConvertible<Y*,T*>>();
			attach();
		}
		weak_ptr(weak_ptr const& r) noexcept
			: _obj(r._obj) {
			attach();
		}
		template<class Y>
		weak_ptr(weak_ptr<Y> const& r) noexcept
			: _obj((refobject<T>*)r._obj) {
			function_requires<IsConvertible<Y*,T*>>();
			attach();
		}

		// 20.7.2.3.2, destructor
		~weak_ptr() {
			detach();
		}

		// 20.7.2.3.3, assignment
		weak_ptr& operator=(weak_ptr const& r) noexcept {
			detach();
			_obj = r._obj;
			attach();
			return *this;
		}
		template<class Y>
		weak_ptr& operator=(weak_ptr<Y> const& r) noexcept {
			function_requires<IsConvertible<Y*,T*>>();
			detach();
			_obj = (refobject<T>*)r._obj;
			attach();
			return *this;
		}
		template<class Y>
		weak_ptr& operator=(shared_ptr<Y> const& r) noexcept {
			function_requires<IsConvertible<Y*,T*>>();
			detach();
			_obj = (refobject<T>*)r._obj;
			attach();
			return *this;
		}

		// 20.7.2.3.4, modifiers
		void swap(weak_ptr& r) noexcept {
			std::swap(_obj,r._obj);
		}
		void reset() noexcept {
			weak_ptr().swap(*this);
		}

		// 20.7.2.3.5, observers
		long use_count() const noexcept {
			return _obj ? _obj->shared_refs : 0;
		}
		bool expired() const noexcept {
			return use_count() == 0;
		}
		shared_ptr<T> lock() const noexcept {
			return expired() ? shared_ptr<T>() : shared_ptr<T>(*this);
		}

	private:
		void attach() {
			if(_obj)
				_obj->weak_refs++;
		}
		void detach() {
			if(_obj && --_obj->weak_refs == 0) {
				if(_obj->shared_refs == 0)
					delete _obj;
			}
		}

		refobject<T> *_obj;
	};

	// 20.7.2.3.6, specialized algorithms
	template<class T>
	void swap(weak_ptr<T>& a, weak_ptr<T>& b) noexcept {
		a.swap(b);
	}
}
