# -*- Mode: Python -*-

import sys, os

target = os.environ.get('ESC_TARGET') or 'x86_64'
if target == 'i586':
	cross = 'i586-elf-escape'
elif target == 'eco32':
	cross = 'eco32-elf-escape'
elif target == 'mmix':
	cross = 'mmix-elf-escape'
else:
	print "Please define ESC_TARGET to i586, eco32 or mmix first!"
	Exit(1)
crossver = '4.6.3'
crossdir = '/opt/escape-cross-' + target

hostenv = Environment(
	ENV = os.environ,
	CXXFLAGS = '-Wall -Wextra -ansi -g'
)
env = Environment(
	CFLAGS = '-Wall -ansi -Wextra -Wshadow -Wpointer-arith -Wcast-align -Wwrite-strings'
			+ ' -Wmissing-prototypes -Wmissing-declarations -Wnested-externs -Winline'
			+ ' -Wno-long-long -Wstrict-prototypes -fms-extensions',
	CXXFLAGS = '-Wall -ansi -Wextra -Wshadow -Wpointer-arith -Wcast-align -Wwrite-strings'
			+ ' -Wmissing-declarations -Wno-long-long',
	ASFLAGS = '-Wa,--warn',
	ENV = {'PATH' : crossdir + "/bin:" + os.environ['PATH']},
	CPPPATH = ['#include', '#include/cpp'],
	CXX = cross + '-g++',
	LD = cross + '-ld',
	AS = cross + '-as',
	CC = cross + '-gcc',
	AR = cross + '-ar',
	RANLIB = cross + '-ranlib',
)

linktype = os.environ.get('ESC_LINKTYPE')
if linktype != 'static':
	linktype = 'dynamic'
gcclinktype = os.environ.get('ESC_GCCLINKTYPE')
if gcclinktype == 'static':
	env.Append(LINKFLAGS = ' -static-libgcc')

btype = os.environ.get('ESC_BUILD')
if btype == 'debug':
	env.Append(
		CFLAGS = ' -O0 -fno-builtin -ggdb -D LOGSERIAL',
		CXXFLAGS = ' -O0 -fno-inline -ggdb'
	)
else:
	env.Append(
		CFLAGS = ' -O3 -fno-builtin -DNDEBUG',
		CXXFLAGS = ' -O3 -DNDEBUG'
	)
	btype = 'release'
builddir = 'build/' + target + '-' + btype

if target == 'mmix':
	env.Append(
		# atm we have to disable base-addresses, because the mmix-gcc-port seems to be unable to
		# handle it correctly
		CFLAGS = ' -mno-base-addresses',
		CXXFLAGS = ' -mno-base-addresses',
		# do not warn if instructions are extended to setl,incml,...
		ASFLAGS = ' -x'
	)

verbose = os.environ.get('ESC_VERBOSE',0)
if int(verbose) == 0:
	hostenv['ASCOMSTR'] = env['ASCOMSTR'] = "AS $TARGET"
	hostenv['ASPPCOMSTR'] = env['ASPPCOMSTR'] = "ASPP $TARGET"
	hostenv['CCCOMSTR'] = env['CCCOMSTR'] = "CC $TARGET"
	hostenv['SHCCCOMSTR'] = env['SHCCCOMSTR'] = "SHCC $TARGET"
	hostenv['CXXCOMSTR'] = env['CXXCOMSTR'] = "CXX $TARGET"
	hostenv['SHCXXCOMSTR'] = env['SHCXXCOMSTR'] = "SHCXX $TARGET"
	hostenv['LINKCOMSTR'] = env['LINKCOMSTR'] = "LD $TARGET"
	hostenv['SHLINKCOMSTR'] = env['SHLINKCOMSTR'] = "SHLD $TARGET"
	hostenv['ARCOMSTR'] = env['ARCOMSTR'] = "AR $TARGET"
	hostenv['RANLIBCOMSTR'] = env['RANLIBCOMSTR'] = "RANLIB $TARGET"

env.Append(
	ARCH = target,
	LINKTYPE = linktype,
	ROOTDIR = '#',
	BUILDDIR = '#' + builddir,
	DISTDIR = '#' + builddir + '/dist',
	BINDIR = '#' + builddir + '/bin',
	SYSLIBPATH = crossdir + '/lib',
	SYSGCCLIBPATH = crossdir + '/lib/gcc/' + cross + '/' + crossver,
	SYSSHGCCPATH = crossdir + '/' + cross + '/lib'
)
env['LIBPATH'] = [env['BINDIR'], env['SYSLIBPATH']]
hostenv['BINDIR'] = env['BINDIR']
link_addr = 0x1000

def SetLibDeps(env, lib, libs):
	for l in libs:
		if l != 'gcc':
			env.Depends(lib, env['BINDIR'] + '/lib' + l + '.so')
	if str(lib[0]) != 'libc.so' and str(lib[0]) != 'libstdc++.so':
		env.Depends(lib, env['BINDIR'] + '/libc.so')
		env.Depends(lib, env['BINDIR'] + '/libstdc++.so')

def SetProgDeps(env, prog, static, libs, cpp):
	crtsuffix = '.o' if static else 'S.o'
	libsuffix = '.a' if static else '.so'
	for l in libs:
		if l != 'gcc':
			env.Depends(prog, env['BINDIR'] + '/lib' + l + libsuffix)
	env.Depends(prog, env['SYSGCCLIBPATH'] + '/crt0' + crtsuffix)
	env.Depends(prog, env['SYSGCCLIBPATH'] + '/crt1' + crtsuffix)
	env.Depends(prog, env['SYSGCCLIBPATH'] + '/crtn' + crtsuffix)
	env.Depends(prog, env['BINDIR'] + '/libc' + libsuffix)
	env.Depends(prog, env['BINDIR'] + '/libg' + libsuffix)
	env.Depends(prog, env['BINDIR'] + '/libm' + libsuffix)
	if cpp:
		env.Depends(prog, env['BINDIR'] + '/libstdc++' + libsuffix)
		if static:
			env.Depends(prog, env['SYSGCCLIBPATH'] + '/libgcc.a')
		else:
			env.Depends(prog, env['SYSSHGCCPATH'] + '/libgcc_s.so.1')
		env.Depends(prog, env['SYSLIBPATH'] + '/libsupc++.a')

def SetLinkAddr(env, static):
	global link_addr
	if static:
		env.Append(LINKFLAGS = ' -Wl,--section-start=.init=' + ("0x%x" % link_addr))
	else:
		env.Append(LINKFLAGS = ' -Wl,--section-start=.interp=' + ("0x%x" % link_addr))
	link_addr += 0x20000

def EscapeDump(env, target, source):
	dump = env.Command(target, source, env['BINDIR'][1:] + '/hostdump $SOURCE > $TARGET')
	env.Depends(dump, env['BINDIR'] + '/hostdump')
	env.Install(env['BUILDDIR'], dump)

def EscapeCProg(env, prefix, target, source, force_static = False, LIBS = []):
	myenv = env.Clone()
	static = force_static or env['LINKTYPE'] == 'static'
	if static:
		myenv.Append(LINKFLAGS = ' -static -Wl,-static')
	if target != 'escape' and target != 'escape_test' and target != 'dynlink' and target != 'initloader':
		SetLinkAddr(myenv, static)
	prog = myenv.Program(target, source, LIBS = LIBS)
	SetProgDeps(myenv, prog, static, LIBS, False)
	myenv.Install(myenv['DISTDIR'] + '/' + prefix, prog)
	myenv.Symlink(myenv['BINDIR'] + '/' + target, prog)
	return prog

def EscapeCXXProg(env, prefix, target, source, force_static = False, LIBS = []):
	myenv = env.Clone()
	static = force_static or env['LINKTYPE'] == 'static'
	if static:
		myenv.Append(LINKFLAGS = ' -static -Wl,-static')
	SetLinkAddr(myenv, static)
	prog = myenv.Program(target, source, LIBS = ['stdc++', 'supc++'] + LIBS)
	SetProgDeps(myenv, prog, static, LIBS, True)
	myenv.Install(myenv['DISTDIR'] + '/' + prefix, prog)
	myenv.Symlink(myenv['BINDIR'] + '/' + target, prog)
	return prog

def EscapeLib(env, target, source, LIBS = []):
	myenv = env.Clone()
	stlib = myenv.StaticLibrary(target, source)
	shenv = myenv.Clone()
	shenv.Append(LINKFLAGS = ' -Wl,-shared -Wl,-soname,lib' + target + '.so')
	shlib = shenv.SharedLibrary(target, source, LIBS = LIBS)
	SetLibDeps(env, shlib, LIBS)
	env.Install(env['BINDIR'], [stlib, shlib])
	env.Install(env['DISTDIR'] + '/lib', shlib)

symlink = Builder(action = 'ln -sf ${SOURCE.abspath} $TARGET')
env.Append(BUILDERS = {'Symlink' : symlink})
env.EscapeDump = EscapeDump
env.EscapeCProg = EscapeCProg
env.EscapeCXXProg = EscapeCXXProg
env.EscapeLib = EscapeLib

hostenv.SConscript('tools/SConscript', 'hostenv',
				   variant_dir = builddir + '/tools', duplicate = 0)

for d in ['dist', 'lib', 'drivers', 'user', 'kernel']:
	env.SConscript(d + '/SConscript', 'env',
				   variant_dir = builddir + '/' + d, duplicate = 0)

# EOF
