                   # 1 "kernel/exceptions1.mms"
                   # 1 "<built-in>"
                   # 1 "<command-line>"
                   # 1 "kernel/exceptions1.mms"
                   %
                   % exceptions1.mms -- test exceptions in usermode
                   %
                   
                     % segmentsizes: 3,3,3,4; pageSize=2^13; r=0x90000; n=256
                     LOC #8000
0000000000008000:  RV OCTA #33340D0000090800
 ...000: 33340d00
 ...004: 00090800
                   
                     % -- PTEs to be able to execute the code --
                     LOC #00090000
0000000000090000:    OCTA #0000000000000801 % PTE 0 (#0000000000000000 .. #0000000000001FFF)
 ...000: 00000000
 ...004: 00000801
                     LOC #00090008
 ...008: 00000000    OCTA #0000000000002801 % PTE 1 (#0000000000002000 .. #0000000000003FFF)
 ...00c: 00002801
                     LOC #00090010
 ...010: 00000000    OCTA #0000000000004801 % PTE 2 (#0000000000004000 .. #0000000000005FFF)
 ...014: 00004801
                     % -- PTEs to be able to access the stack --
                     LOC #00096000
0000000000096000:    OCTA #0000000000600807 % PTE 0 (#6000000000000000 .. #6000000000001FFF)
 ...000: 00000000
 ...004: 00600807
                   
                     % -- PTPs and PTEs for testing exceptions --
                     % n does not match in PTP1
                     LOC #00092008
0000000000092008:    OCTA #8000000000400400 % PTP1 0 (#0000000000800000 .. #0000000000FFFFFF)
 ...008: 80000000
 ...00c: 00400400
                     LOC #00400000
0000000000400000:    OCTA #0000000000202807 % PTE 0 (#0000000000800000 .. #0000000000801FFF)
 ...000: 00000000
 ...004: 00202807
                     % n does not match in PTE
                     LOC #00092010
0000000000092010:    OCTA #8000000000402800 % PTP1 1 (#0000000001000000 .. #00000000017FFFFF)
 ...010: 80000000
 ...014: 00402800
                     LOC #00402000
0000000000402000:    OCTA #0000000000204407 % PTE 0 (#0000000001000000 .. #0000000001001FFF)
 ...000: 00000000
 ...004: 00204407
                     % PTE not readable
                     LOC #00090018
0000000000090018:    OCTA #0000000000206803 % PTE 3 (#0000000000006000 .. #0000000000007FFF)
 ...018: 00000000
 ...01c: 00206803
                     % PTE not writable
                     LOC #00090020
 ...020: 00000000    OCTA #0000000000208804 % PTE 4 (#0000000000008000 .. #0000000000009FFF)
 ...024: 00208804
                     % PTE not writable, not readable
                     LOC #00090028
 ...028: 00000000    OCTA #000000000020A800 % PTE 5 (#000000000000A000 .. #000000000000BFFF)
 ...02c: 0020a800
                     % PTE writable, not readable
                     LOC #00090030
 ...030: 00000000    OCTA #000000000020C802 % PTE 6 (#000000000000C000 .. #000000000000DFFF)
 ...034: 0020c802
                   
                   
                     % data for writing to M[#8000], M[#A000], M[#C000]
                     LOC #208000
0000000000208000:    OCTA #123456789ABCDEF
 ...000: 01234567
 ...004: 89abcdef
                     LOC #20A000
000000000020a000:    OCTA #123456789ABCDEF
 ...000: 01234567
 ...004: 89abcdef
                     LOC #20C000
000000000020c000:    OCTA #123456789ABCDEF
 ...000: 01234567
 ...004: 89abcdef
                   
                   
                     % stack for unsave
                     LOC #600000
0000000000600000:    OCTA #0 % rL
 ...000: 00000000
 ...004: 00000000
 ...008: 00000000    OCTA #0 % $250 = fa
 ...00c: 00000000
 ...010: 00000000    OCTA #0 % $251 = fb
 ...014: 00000000
 ...018: 00000000    OCTA #0 % $252 = fc
 ...01c: 00000000
 ...020: 00000000    OCTA #0 % $253 = fd
 ...024: 00000000
 ...028: 00000000    OCTA #0 % $254 = fe
 ...02c: 00000000
 ...030: 00000000    OCTA #0 % $255 = ff
 ...034: 00000000
 ...038: 00000000    OCTA #0 % rB
 ...03c: 00000000
 ...040: 00000000    OCTA #0 % rD
 ...044: 00000000
 ...048: 00000000    OCTA #0 % rE
 ...04c: 00000000
 ...050: 00000000    OCTA #0 % rH
 ...054: 00000000
 ...058: 00000000    OCTA #0 % rJ
 ...05c: 00000000
 ...060: 00000000    OCTA #0 % rM
 ...064: 00000000
 ...068: 00000000    OCTA #0 % rP
 ...06c: 00000000
 ...070: 00000000    OCTA #0 % rR
 ...074: 00000000
 ...078: 00000000    OCTA #0 % rW
 ...07c: 00000000
 ...080: 00000000    OCTA #0 % rX
 ...084: 00000000
 ...088: 00000000    OCTA #0 % rY
 ...08c: 00000000
 ...090: 00000000    OCTA #0 % rZ
 ...094: 00000000
 ...098: fa000000  ADDR OCTA #FA00000000000000 % rG | rA
 ...09c: 00000000
                   
                   
                     % dynamic trap address
                     LOC #800000
                   
0000000000800000:  ATRAP BZ $8,_DEF % if $8 != 0, use $8 as rWW
 ...000: 4208xxxx
 ...004: 21fc0800    ADD $252,$8,0
 ...008: f61c0008    PUT rWW,$8
 ...00c: f0xxxxxx    JMP _DONE
 ...010: fefc001c  _DEF GET $252,rWW % get rWW - 4
 ...014: 27fcfc04  _DONE SUBU $252,$252,4
 ...018: fefd0010    GET $253,rQ % or rQ in
 ...01c: c0fdfdfc    OR $253,$253,$252
 ...020: affdfe00    STOU $253,$254,0 % store it
 ...024: fefb001d    GET $251,rXX
 ...028: ecfb8000    ANDNH $251,#8000 % zero MSB (may be different, if mmmix continues the instr)
 ...02c: 3ffbfb20    SRU $251,$251,32 % use the upper 32 bit
 ...030: affbfe08    STOU $251,$254,8 % store it
 ...034: fefb001e    GET $251,rYY
 ...038: affbfe10    STOU $251,$254,16 % store rYY
 ...03c: fefb001f    GET $251,rZZ
 ...040: affbfe18    STOU $251,$254,24 % store rZZ
 ...044: 21fefe20    ADD $254,$254,32
 ...048: f7100000    PUT rQ,0 % reset rQ
 ...04c: 42faxxxx    BZ $250,_END % if $250 != 0, set sign-bit in rXX to skip instruction
 ...050: fefd001d    GET $253,rXX
 ...054: e8fd8000    ORH $253,#8000
 ...058: f61d00fd    PUT rXX,$253
 ...05c: e3ff000f  _END SETL $255,#000F
 ...060: e9ff00ff    ORMH $255,#00FF % set rK
 ...064: f9000001    RESUME 1
                   
                   
                     % forced trap address
                     LOC #700000
                   
0000000000700000:  QUIT SETH $0,#8000
 ...000: e0008000
 ...004: eb004000    ORL $0,#4000
 ...008: b9ff0000    SYNCD #FF,$0,0
 ...00c: 230000ff    ADDU $0,$0,#FF
 ...010: b9ff0000    SYNCD #FF,$0,0
 ...014: 230000ff    ADDU $0,$0,#FF
 ...018: b9ff0000    SYNCD #FF,$0,0
 ...01c: 230000ff    ADDU $0,$0,#FF
 ...020: b9ff0000    SYNCD #FF,$0,0
 ...024: 230000ff    ADDU $0,$0,#FF
 ...028: b9ff0000    SYNCD #FF,$0,0
 ...02c: 00000000    TRAP 0
                   
                   
                     LOC #1000
                   
                     % first setup basic paging: 0 mapped to 0
0000000000001000:  Main SETL $0,RV
 ...000: e3008000
 ...004: e8008000    ORH $0,#8000
 ...008: 8f000000    LDOU $0,$0
 ...00c: f6120000    PUT rV,$0
                   
                     % setup our environment
 ...010: e0006000    SETH $0,#6000
******************   ORL $0,ADDR
************ warning: YZ field doesn't fit in two bytes
 ...014: eb000098
 ...018: fb000000    UNSAVE $0
                   
                     % global registers are better here because of PUSH/POP
 ...01c: f7130080    PUT rG,128
                     % setup rTT
 ...020: e0008000    SETH $0,#8000
 ...024: e9000000    ORMH $0,ATRAP>>32
 ...028: ea000080    ORML $0,ATRAP>>16
******************   ORL $0,ATRAP>>0
************ warning: YZ field doesn't fit in two bytes
 ...02c: eb000000
 ...030: f60e0000    PUT rTT,$0
                     % setup rT
 ...034: e0008000    SETH $0,#8000
 ...038: e9000000    ORMH $0,QUIT>>32
 ...03c: ea000070    ORML $0,QUIT>>16
******************   ORL $0,QUIT>>0
************ warning: YZ field doesn't fit in two bytes
 ...040: eb000000
 ...044: f60d0000    PUT rT,$0
                     % setup address for results
 ...048: e0fe8000    SETH $254,#8000
 ...04c: ebfe4000    ORL $254,#4000
                     % set rK
 ...050: e10000fe    SETMH $0,#00FE
 ...054: f60f0000    PUT rK,$0
                   
                     % now go to user-mode (we are at #8000000000001000 atm)
 ...058: e300000f    SETL $0,#000F
 ...05c: e90000ff    ORMH $0,#00FF % have to be set in usermode
 ...060: c1ff0000    SET $255,$0
 ...064: e3002000    SET $0,#2000
 ...068: f61c0000    PUT rWW,$0
 ...06c: e0008000    SETH $0,#8000
 ...070: f61d0000    PUT rXX,$0
 ...074: f9000001    RESUME 1
                   
                     LOC #2000
                   
                     % go from non-negative to negative address
0000000000002000:    SETH $0,#8000
 ...000: e0008000
                     % special case: the pc is set BEFORE the exception occurs. and $X is set as well.
                     % therefore we set $8 to use that as rWW
 ...004: 9f080000    GO $8,$0,0
                   
                     % reset $8
 ...008: e3080000    SET $8,0
                   
                     % use a special-register >= 32 with put
 ...00c: f7210004    PUT 33,#4
                   
                     % write to readonly registers
 ...010: f7080004    PUT rC,#4
 ...014: f7090004    PUT rN,#4
 ...018: f70a0004    PUT rO,#4
 ...01c: f70b0004    PUT rS,#4
                   
                     % write to privileged registers
 ...020: f70c0004    PUT rI,#4
 ...024: f70d0004    PUT rT,#4
 ...028: f70e0004    PUT rTT,#4
 ...02c: f70f0004    PUT rK,#4
 ...030: f7100004    PUT rQ,#4
 ...034: f7110004    PUT rU,#4
 ...038: f7120004    PUT rV,#4
                   
                     % save with a wrong target-register
 ...03c: fa000000    SAVE $0,0 % illegal because $0 < rG
 ...040: fa010000    SAVE $1,0 % illegal because $1 < rG
 ...044: fa7f0000    SAVE $127,0 % illegal because $127 < rG
                   
 ...048: e3fa0001    SET $250,1 % set sign-bit in rXX to skip instruction
                   
                     % access page where n does not match in PTP1
 ...04c: e2000080    SETML $0,#0080
 ...050: eb000000    ORL $0,#0000
 ...054: 8f000008    LDOU $0,$0,8 % #800008
                   
                     % access page where n does not match in PTE
 ...058: e2000100    SETML $0,#0100
 ...05c: eb000000    ORL $0,#0000
 ...060: 8f000000    LDOU $0,$0,0 % #1000000
                   
                     % write to not-readable, writable page (wyde)
 ...064: e300c001    SETL $0,#C001
 ...068: a7010000    STWU $1,$0,0
                   
                     % write to page with invalid n (wyde)
 ...06c: e2000100    SETML $0,#0100
 ...070: eb000000    ORL $0,#0000
 ...074: a7010000    STWU $1,$0,0
                   
 ...078: e3fa0000    SET $250,0 % no longer necessary
                   
                     % jump to a privileged address via resume
 ...07c: e0008000    SETH $0,#8000
 ...080: f4010004    GETA $1,@+16
 ...084: c0000001    OR $0,$0,$1
 ...088: f6180000    PUT rW,$0
 ...08c: f9000000    RESUME 0
 ...090: f7180000    PUT rW,0
                   
                     % use the privileged RESUME_TRANS
 ...094: e0000300    SETH $0,#0300
 ...098: f6190000    PUT rX,$0
 ...09c: f4000003    GETA $0,@+12
 ...0a0: f6180000    PUT rW,$0
 ...0a4: f9000000    RESUME 0
                   
                     % use an invalid ropcode
 ...0a8: e0000400    SETH $0,#0400
 ...0ac: f6190000    PUT rX,$0
 ...0b0: f4000003    GETA $0,@+12
 ...0b4: f6180000    PUT rW,$0
 ...0b8: f9000000    RESUME 0
                   
                     % try to increase rL via RESUME_SET
 ...0bc: e0000200    SETH $0,#0200
 ...0c0: ea000020    ORML $0,#0020
 ...0c4: f6190000    PUT rX,$0
 ...0c8: f4000003    GETA $0,@+12
 ...0cc: f6180000    PUT rW,$0
 ...0d0: f9000000    RESUME 0
                   
                     % use invalid instruction with RESUME_CONT
 ...0d4: e0000100    SETH $0,#0100
 ...0d8: ea004000    ORML $0,#4000
 ...0dc: f6190000    PUT rX,$0
 ...0e0: f4000003    GETA $0,@+12
 ...0e4: f6180000    PUT rW,$0
 ...0e8: f9000000    RESUME 0
                   
                     % try to increase rL via RESUME_CONT
 ...0ec: e0000100    SETH $0,#0100
 ...0f0: ea000020    ORML $0,#0020
 ...0f4: f6190000    PUT rX,$0
 ...0f8: f4000003    GETA $0,@+12
 ...0fc: f6180000    PUT rW,$0
 ...100: f9000000    RESUME 0
                   
                     % try to use RESUME via RESUME_AGAIN
 ...104: e0000000    SETH $0,#0000
 ...108: ea00f900    ORML $0,#F900
 ...10c: f6190000    PUT rX,$0
 ...110: f4000003    GETA $0,@+12
 ...114: f6180000    PUT rW,$0
 ...118: f9000000    RESUME 0
                   
                     % put invalid bits in rQ
 ...11c: e2000001    SETML $0,#0001
 ...120: f6100000    PUT rQ,$0
                   
 ...124: 00000001    TRAP 1

Symbol table:
 ADDR = #0000000000600098 (3)
 ATRAP = #0000000000800000 (5)
 Main = #0000000000001000 (1)
 QUIT = #0000000000700000 (8)
 RV = #0000000000008000 (2)
 _DEF = #0000000000800010 (4)
 _DONE = #0000000000800014 (6)
 _END = #000000000080005c (7)
