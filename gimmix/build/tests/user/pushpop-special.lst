                   # 1 "user/pushpop-special.mms"
                   # 1 "<built-in>"
                   # 1 "<command-line>"
                   # 1 "user/pushpop-special.mms"
                   %
                   % pushpop-special.mms -- tests push/pop (special cases)
                   %
                   
                     LOC #1000
                   
0000000000001000:  Main PUT rG,64
 ...000: f7130040
 ...004: f7140000    PUT rL,0 % discard arguments in mmix/mmmix
                   
                   
                     % jump over instructions with pop
 ...008: e3400000    SET $64,0
 ...00c: f200xxxx    PUSHJ $0,1F
 ...010: f8000002  1H POP 0,2
 ...014: 21404001    ADD $64,$64,1 % not executed
 ...018: 21404001    ADD $64,$64,1
                   
                   
                     % returning more values than we have
 ...01c: f7140000    PUT rL,0
 ...020: e3000010    SET $0,#10
 ...024: f201xxxx    PUSHJ $1,2F
 ...028: fe410014    GET $65,rL % 1 return + 1 hole + 1 preserved -> 3
 ...02c: 21420000    ADD $66,$0,0 % #10
 ...030: 21430100    ADD $67,$1,0 % #0
 ...034: 21440200    ADD $68,$2,0 % #11
 ...038: f0xxxxxx    JMP 3F
                   
 ...03c: e3000011  2H SET $0,#11
 ...040: f8030000    POP 3,0
                   
                   
                     % returning a value with rL = 0
 ...044: f7140000  3H PUT rL,0
 ...048: e3000010    SET $0,#10
 ...04c: f201xxxx    PUSHJ $1,4F
 ...050: fe450014    GET $69,rL % 0 return + 1 hole + 1 preserved -> 2
 ...054: 21460000    ADD $70,$0,0 % #10
 ...058: 21470100    ADD $71,$1,0 % #0
 ...05c: f0xxxxxx    JMP 5F
                   
 ...060: f8010000  4H POP 1,0
                   
                   
                     % push all local registers
 ...064: f7140000  5H PUT rL,0
 ...068: e3021234    SET $2,#1234
 ...06c: f2ffxxxx    PUSHJ $255,6F
 ...070: fe490014    GET $73,rL % 3
 ...074: 214a0200    ADD $74,$2,0 % #1234
 ...078: f0xxxxxx    JMP 7F
 ...07c: fe480014  6H GET $72,rL % 0
 ...080: f8000000    POP 0,0
                   
                   
                     % manipulate the stack: give pop a value > rG for the number of registers of the caller
 ...084: e33f0000  7H SET $63,0
 ...088: f240xxxx    PUSHJ $64,1F
                   
 ...08c: fe000004  1H GET $0,rJ
 ...090: e33f0000    SET $63,0
 ...094: f240xxxx    PUSHJ $64,2F
 ...098: fe4b0014    GET $75,rL % should be 64, not 65
 ...09c: 00000000    TRAP 0 % we can't really continue here because we've destroyed our
                            % stack (loaded 1 value too much from the stack)
                   
                   
 ...0a0: fe000004  2H GET $0,rJ
 ...0a4: e33f0000    SET $63,0
 ...0a8: f240xxxx    PUSHJ $64,3F
 ...0ac: f6040000    PUT rJ,$0
 ...0b0: f8000000    POP 0,0
                   
 ...0b4: fe000004  3H GET $0,rJ
 ...0b8: e33f0000    SET $63,0
 ...0bc: f240xxxx    PUSHJ $64,4F
 ...0c0: f6040000    PUT rJ,$0
 ...0c4: f8000000    POP 0,0
                   
 ...0c8: fe000004  4H GET $0,rJ
 ...0cc: e33f0000    SET $63,0
 ...0d0: f240xxxx    PUSHJ $64,5F
 ...0d4: f6040000    PUT rJ,$0
 ...0d8: f8000000    POP 0,0
                   
 ...0dc: e33f0000  5H SET $63,0
 ...0e0: e0006000    SETH $0,#6000
 ...0e4: eb000408    ORL $0,#0408
 ...0e8: b5410000    STCO 65,$0,0 % overwrite it
 ...0ec: f8000000    POP 0,0

Symbol table:
 Main = #0000000000001000 (1)
