// RTTI support for -*- C++ -*-
// Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
// 2003, 2004, 2005, 2006, 2007, 2009
// Free Software Foundation
//
// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3, or (at your option)
// any later version.
// 
// GCC is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file typeinfo
 *  This is a Standard C++ Library header.
 */

#ifndef _TYPEINFO
#define _TYPEINFO

#include "exception"

#pragma GCC visibility push(default)

extern "C++" {

	namespace __cxxabiv1 {
		class __class_type_info;
	} // namespace __cxxabiv1

	namespace std {
		/**
		 *  @brief  Part of RTTI.
		 *
		 *  The @c type_info class describes type information generated by
		 *  an implementation.
		 */
		class type_info {
		public:
			/** Destructor first. Being the first non-inline virtual function, this
			 *  controls in which translation unit the vtable is emitted. The
			 *  compiler makes use of that information to know where to emit
			 *  the runtime-mandated type_info structures in the new-abi.  */
			virtual ~type_info();

			/** Returns an @e implementation-defined byte string; this is not
			 *  portable between compilers!  */
			const char* name() const {
				return __name;
			}

			/** Returns true if @c *this precedes @c __arg in the implementation's
			 *  collation order.  */
			// In new abi we can rely on type_info's NTBS being unique,
			// and therefore address comparisons are sufficient.
			bool before(const type_info& __arg) const {
				return __name < __arg.__name;
			}

			bool operator==(const type_info& __arg) const {
				return __name == __arg.__name;
			}

			bool operator!=(const type_info& __arg) const {
				return !operator==(__arg);
			}

			// Return true if this is a pointer type of some kind
			virtual bool __is_pointer_p() const;

			// Return true if this is a function type
			virtual bool __is_function_p() const;

			// Try and catch a thrown type. Store an adjusted pointer to the
			// caught type in THR_OBJ. If THR_TYPE is not a pointer type, then
			// THR_OBJ points to the thrown object. If THR_TYPE is a pointer
			// type, then THR_OBJ is the pointer itself. OUTER indicates the
			// number of outer pointers, and whether they were const
			// qualified.
			virtual bool __do_catch(const type_info *__thr_type,void **__thr_obj,
					unsigned __outer) const;

			// Internally used during catch matching
			virtual bool __do_upcast(const __cxxabiv1:: __class_type_info *__target,
			void **__obj_ptr) const;

		protected:
			const char *__name;

			explicit type_info(const char *__n): __name(__n) {}

		private:
			/// Assigning type_info is not supported.
			type_info& operator=(const type_info&);
			type_info(const type_info&);
		};

		/**
		 *  @brief  Thrown during incorrect typecasting.
		 *  @ingroup exceptions
		 *
		 *  If you attempt an invalid @c dynamic_cast expression, an instance of
		 *  this class (or something derived from this class) is thrown.  */
		class bad_cast : public exception
		{
		public:
			bad_cast() throw() {}

			// This declaration is not useless:
			// http://gcc.gnu.org/onlinedocs/gcc-3.0.2/gcc_6.html#SEC118
			virtual ~bad_cast() throw();

			// See comment in eh_exception.cc.
			virtual const char* what() const throw();
		};

		/**
		 *  @brief Thrown when a NULL pointer in a @c typeid expression is used.
		 *  @ingroup exceptions
		 */
		class bad_typeid : public exception
		{
		public:
			bad_typeid () throw() {}

			// This declaration is not useless:
			// http://gcc.gnu.org/onlinedocs/gcc-3.0.2/gcc_6.html#SEC118
			virtual ~bad_typeid() throw();

			// See comment in eh_exception.cc.
			virtual const char* what() const throw();
		};
	} // namespace std

#pragma GCC visibility pop

} // extern "C++"
#endif
